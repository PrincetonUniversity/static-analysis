# Analyze ellipswarm static data

using DataFrames

export process

"""
    process(file[, α][, nbins])

`process` computes personal information and social influence
for groups of particles and returns a DataFrame.

`file` is a path to an HDF5 file containing the data as
generated by ellipswarm's `static` command.

`α` and `nbins` are keyword arguments for the inverse of the
generalized radius of the α-shape used for finding the edges
of each group, and the number of bins to use for aggregating
the data.
"""
#"process computes personal information and social influence for groups of particles."
function process(file::AbstractString; α::Real = -0.2, nbins::Integer = 11)
    # α-shape radius = 25cm = 5 body width => α = -0.2

    p, mask = h5read_particles(file)
    pi = h5read(file, "personal")
    si = h5read(file, "social")

    N = size(p, 1) # max swarm size
    K = size(p, 2) # replicates

    # distance from edge
    dem = zeros(N, K)
    println("Computing distance from edge…")
    for k=1:K
        @printf("\r%3d%%", 100(k-1) / K)
        nz = mask[:,k]
        dem[nz,k] = dist_from_edge(α, p[nz,k])
    end
    de_max = maximum(dem)
    println("\r100%")

    # distances, order parameters, dataframe
    println("Building DataFrame…")
    cols = [
        (:DistFromBack,       Float64),
        (:DistFromEdge,       Float64),
        (:DistFromEdgeRel,    Float64),
        (:BinFromBack,        Int),
        (:BinFromEdge,        Int),
        (:BinFromEdgeRel,     Int),
        (:BinDistFromBack,    Float64),
        (:BinDistFromEdge,    Float64),
        (:BinDistFromEdgeRel, Float64),
        (:Swarm,              Int),
        (:SwarmPolarization,  Float64),
        (:SwarmRotation,      Float64),
        (:SwarmState,         Symbol),
        (:Info,               Float64),
        (:Kind,               Symbol),
    ]
    df = DataFrame([x[2]::DataType for x in cols], [x[1]::Symbol for x in cols], 0)
    for k=1:K
        @printf("\r%3d%%", 100(k-1) / K)
        nz = mask[:,k]

        # distances
        db = dist_from_back(p[nz,k])
        de = dem[nz,k]
        de_rel = de ./ maximum(de)

        # bins
        db_bin, db_bin_dist = bindist(db, (0, 1), nbins)
        de_bin, de_bin_dist = bindist(de, (0, de_max), nbins)
        de_bin_rel, de_bin_dist_rel = bindist(de_rel, (0, 1), nbins)

        # order parameters and state
        op, or = order_parameters(p[nz,k])
        if op > 0.65 && or < 0.35
            state = :Polarized
        elseif op < 0.35 && or > 0.65
            state = :Milling
        elseif op < 0.35 && or < 0.35
            state = :Swarming
        else
            state = :Transitioning
        end

        # social influence
        # FIXME: should just be cc(si[nz,nz,k])
        # msi = cc(si[nz,nz,k])
        w = si[nz,nz,k]
        msi = cc(w .* (w .> 1e-3)) # 1e-4

        # append to dataframe
        row = DataFrame(
            DistFromBack       = db,
            DistFromEdge       = de,
            DistFromEdgeRel    = de_rel,
            BinFromBack        = db_bin,
            BinFromEdge        = de_bin,
            BinFromEdgeRel     = de_bin_rel,
            BinDistFromBack    = db_bin_dist,
            BinDistFromEdge    = de_bin_dist,
            BinDistFromEdgeRel = de_bin_dist_rel,
            Swarm              = k,
            SwarmPolarization  = op,
            SwarmRotation      = or,
            SwarmState         = state,
            Info               = pi[nz,k],
            Kind               = :Personal,
        )
        append!(df, row)
        row[:Info] = msi
        row[:Kind] = :Social
        append!(df, row)
    end
    println("\r100%")

    return df
end

function runscale()
    lab = ["1÷2", "1÷√2", "1", "√2", "2"]
    val = [1/2, 1/√2, 1, √2, 2]
    println("> data/scale/fullscaled_$(lab[1]).h5")
    df = process("data/scale/fullscaled_$(lab[1]).h5", α = -0.2 / val[1])
    df[:Scale] = val[1]
    for i in 2:5
        println("> data/scale/fullscaled_$(lab[i]).h5")
        df2 = process("data/scale/fullscaled_$(lab[i]).h5", α = -0.2 / val[i])
        df2[:Scale] = val[i]
        append!(df, df2)
    end
    writetable("data/scale/df.csv", df)
    df
end

function runsize(mode)
    println("> size/data_5.0_$(mode).h5")
    _, _, dfb, dfe = run("size/data_5.0_$(mode).h5")
    dfb[:Size] = 5.0
    dfe[:Size] = 5.0
    for size in 10.0:5.0:25.0
        println("> size/data_$(size)_$(mode).h5")
        _, _, dfb2, dfe2 = run("size/data_$(size)_$(mode).h5", -0.2)
        dfb2[:Size] = size
        dfe2[:Size] = size
        append!(dfb, dfb2)
        append!(dfe, dfe2)
    end
    writetable("size/dfb_$(mode).csv", dfb)
    writetable("size/dfe_$(mode).csv", dfe)
    dfb, dfe
end

"cc computes the local weighted directed clustering coefficient."
function cc(w::Matrix{Float64})
    # assuming w is square weight matrix
    n = size(w, 1)
    a = w .!= 0 # adjacency matrix
    CC = zeros(n)
    for i=1:n
        dg, db, C = 0.0, 0.0, 0.0
        for j=1:n
            for k=1:n
                C += (w[i,j] + w[j,i]) * (w[i,j] + w[k,i]) * (w[j,k] + w[k,j])
            end
            j != i || continue
            dg += a[i,j] + a[j,i]
            db += a[i,j] * a[j,i]
        end
        CC[i] = C == 0 ? 0 : C / 2(dg * (dg - 1) - 2db)
    end
    CC
end

"dist_from_back computes the distance of each particle to the back of the swarm."
function dist_from_back(p::Vector{State})
    m = mean(p)
    db = similar(p, Float64)
    for i in eachindex(p)
        @inbounds db[i] = dot(p[i].pos - m.pos, Vec2(cos(p[i].dir), sin(p[i].dir)))
    end
    min, max = extrema(db)
    (db - min) ./ (max - min)
end

"dist_from_edge computes the distance of each particle to the edge of the α-shape."
function dist_from_edge(α::Real, p::Vector{State})
    de = similar(p, Float64)
    outer, inner, degen, solo = alphashape(α, p)
    @inbounds for i in eachindex(p)
        if i in solo
            de[i] = NaN
            continue
        end
        dmin = Inf
        m = p[i].pos
        for kind in (outer, degen), v in kind, j=2:length(v)
            a, b = p[v[j-1]].pos, p[v[j]].pos
            u = b - a
            t = dot(m - a, u) / norm(u)
            d = norm(a + clamp(t, 0, 1) * u - m)
            dmin = min(dmin, d)
        end
        de[i] = dmin
    end
    de
end

function dist_from_edge(α::Real, p::Vector{State}, grid::Matrix{Vec2})
    d = Vector{Float64}(length(grid))
    outer, inner, degen, solo = alphashape(α, p)
    @inbounds for i in eachindex(grid)
        dmin = Inf
        m = grid[i]
        for kind in (outer, degen), v in kind, j=2:length(v)
            a, b = p[v[j-1]].pos, p[v[j]].pos
            u = b - a
            t = dot(m - a, u) / norm(u)
            d0 = norm(a + clamp(t, 0, 1) * u - m)
            dmin = min(dmin, d0)
        end
        d[i] = dmin
        if any([inpolygon(m, Vec2[x.pos for x in p[v]]) for v in outer])
            d[i] = -dmin
        end
    end
    return d
end

"order_parameters computes the polarization and rotation of a swarm."
function order_parameters(p::Vector{State})
    m = mean(p)
    up, ur = Vec2(0, 0), 0.0
    @inbounds for i in eachindex(p)
        u = unit(p[i].vel)
        up += u
        ur += cross(u, unit(p[i].pos - m.pos))
    end
    (norm(up) / length(p), abs(ur) / length(p))
end

function relative_dir(p::Vector{State}, grid::Matrix{Vec2})
    m = mean(p)
    θ = angle(m.vel)
    [angle(grid[i] - m.pos) - θ for i in eachindex(grid)]
end

"bindist returns the ID and center of the nearest bin around each value in v."
function bindist(v::Vector{Float64}, bounds::Tuple{Real, Real}, nbins::Integer)
    edge = linspace(bounds..., nbins + 1)
    center = (edge[1:end-1] + edge[2:end]) / 2
    min, max = center[1], center[end]
    id = zeros(Int, length(v))
    val = zeros(length(v))
    @inbounds for i in eachindex(v)
        if isnan(v[i])
            id[i] = 0
            val[i] = NaN
        else
            id[i] = clamp(1 + round(Int, (nbins - 1) * (v[i] - min) / (max - min)), 1, nbins)
            val[i] = center[id[i]]
        end
    end
    return id, val
end

function run_detect(file::AbstractString; α::Real = -0.2)
    p, mask = h5read_particles(file)
    detections = h5read(file, "detections");

    N = size(p, 1) # max swarm size
    K = size(p, 2) # replicates
    nx, ny = size(detections, 1, 2)

    # distance from edge
    dem = zeros(nx * ny, K)
    grid = [Vec2(x,y) for x in linspace(-50, 50, nx), y in linspace(-50, 50, ny)]
    println("Computing distance from edge…")
    for k=1:K
        @printf("\r%3d%%", 100(k-1) / K)
        nz = mask[:,k]
        dem[:,k] = dist_from_edge(α, p[nz,k], grid)
    end
    de_max = maximum(dem)
    println("\r100%")

    # distances, order parameters, dataframe
    println("Building DataFrame…")
    cols = [
        (:DistFromEdge,       Float64),
        (:InsideMaxDisk,      Bool),
        (:RelativeDir,        Float64),
        (:Swarm,              Int),
        (:SwarmPolarization,  Float64),
        (:SwarmRotation,      Float64),
        (:SwarmState,         Symbol),
        (:Detections,         Int),
    ]
    df = DataFrame([x[2]::DataType for x in cols], [x[1]::Symbol for x in cols], 0)
    for k=1:K
        @printf("\r%3d%%", 100(k-1) / K)
        nz = mask[:,k]

        xmin, xmax = extrema([s.pos.x for s in p[nz,k]])
        ymin, ymax = extrema([s.pos.y for s in p[nz,k]])
        max = min(50 + xmin, 50 - xmax, 50 + ymin, 50 - ymax)

        # order parameters and state, relative direction
        dir = NaN
        op, or = order_parameters(p[nz,k])
        if op > 0.65 && or < 0.35
            state = :Polarized
            dir = relative_dir(p[nz,k], grid)
        elseif op < 0.35 && or > 0.65
            state = :Milling
        elseif op < 0.35 && or < 0.35
            state = :Swarming
        else
            state = :Transitioning
        end

        # append to dataframe
        row = DataFrame(
            DistFromEdge       = dem[:,k],
            InsideMaxDisk      = dem[:,k] .<= max,
            RelativeDir        = dir,
            Swarm              = k,
            SwarmPolarization  = op,
            SwarmRotation      = or,
            SwarmState         = state,
            Detections         = detections[:,:,k][:],
        )
        append!(df, row)
    end
    println("\r100%")

    return df
end
