# Compute personal and social information from ellipswarm/static.

"""
    run_info(file[, α][, nbins])

`run_info` computes personal information and social influence
for groups of particles and returns a DataFrame.

`file` is a path to an HDF5 file containing the data as
generated by ellipswarm's `static` command.

`α` and `nbins` are keyword arguments for the inverse of the
generalized radius of the α-shape used for finding the edges
of each group, and the number of bins to use for aggregating
the data.
"""
function run_info(file::AbstractString; α::Real = -0.2, nbins::Integer = 11)
    # α-shape radius = 25cm = 5 body width => α = -0.2

    p, mask = h5read_particles(file)
    pi = h5read(file, "personal")
    si = h5read(file, "social")

    N = size(p, 1) # max swarm size
    K = size(p, 2) # replicates

    # distance from edge
    dem = zeros(N, K)
    println("Computing distance from edge…")
    for k=1:K
        @printf("\r%3d%%", 100(k-1) / K)
        nz = mask[:,k]
        dem[nz,k] = dist_from_edge(α, p[nz,k])
    end
    de_max = maximum(dem)
    println("\r100%")

    # distances, order parameters, dataframe
    println("Building DataFrame…")
    cols = [
        (:DistFromBack,       Float64),
        (:DistFromEdge,       Float64),
        (:DistFromEdgeRel,    Float64),
        (:BinFromBack,        Int),
        (:BinFromEdge,        Int),
        (:BinFromEdgeRel,     Int),
        (:BinDistFromBack,    Float64),
        (:BinDistFromEdge,    Float64),
        (:BinDistFromEdgeRel, Float64),
        (:Swarm,              Int),
        (:SwarmPolarization,  Float64),
        (:SwarmRotation,      Float64),
        (:SwarmState,         Symbol),
        (:Info,               Float64),
        (:Kind,               Symbol),
    ]
    df = DataFrame([x[2]::DataType for x in cols], [x[1]::Symbol for x in cols], 0)
    for k=1:K
        @printf("\r%3d%%", 100(k-1) / K)
        nz = mask[:,k]

        # distances
        db = dist_from_back(p[nz,k])
        de = dem[nz,k]
        de_rel = de ./ maximum(de)

        # bins
        db_bin, db_bin_dist = bindist(db, (0, 1), nbins)
        de_bin, de_bin_dist = bindist(de, (0, de_max), nbins)
        de_bin_rel, de_bin_dist_rel = bindist(de_rel, (0, 1), nbins)

        # order parameters and state
        op, or = order_parameters(p[nz,k])
        if op > 0.65 && or < 0.35
            state = :Polarized
        elseif op < 0.35 && or > 0.65
            state = :Milling
        elseif op < 0.35 && or < 0.35
            state = :Swarming
        else
            state = :Transitioning
        end

        # social influence
        # FIXME: should just be cc(si[nz,nz,k])
        # msi = cc(si[nz,nz,k])
        w = si[nz,nz,k]
        msi = cc(w .* (w .> 1e-3)) # 1e-4

        # append to dataframe
        row = DataFrame(
            DistFromBack       = db,
            DistFromEdge       = de,
            DistFromEdgeRel    = de_rel,
            BinFromBack        = db_bin,
            BinFromEdge        = de_bin,
            BinFromEdgeRel     = de_bin_rel,
            BinDistFromBack    = db_bin_dist,
            BinDistFromEdge    = de_bin_dist,
            BinDistFromEdgeRel = de_bin_dist_rel,
            Swarm              = k,
            SwarmPolarization  = op,
            SwarmRotation      = or,
            SwarmState         = state,
            Info               = pi[nz,k],
            Kind               = :Personal,
        )
        append!(df, row)
        row[:Info] = msi
        row[:Kind] = :Social
        append!(df, row)
    end
    println("\r100%")

    return df
end


"cc computes the local weighted directed clustering coefficient."
function cc(w::Matrix{Float64})
    # assuming w is square weight matrix
    n = size(w, 1)
    a = w .!= 0 # adjacency matrix
    CC = zeros(n)
    for i=1:n
        dg, db, C = 0.0, 0.0, 0.0
        for j=1:n
            for k=1:n
                C += (w[i,j] + w[j,i]) * (w[i,j] + w[k,i]) * (w[j,k] + w[k,j])
            end
            j != i || continue
            dg += a[i,j] + a[j,i]
            db += a[i,j] * a[j,i]
        end
        CC[i] = C == 0 ? 0 : C / 2(dg * (dg - 1) - 2db)
    end
    CC
end

"dist_from_back computes the distance of each particle to the back of the swarm."
function dist_from_back(p::Vector{State})
    m = mean(p)
    db = similar(p, Float64)
    for i in eachindex(p)
        @inbounds db[i] = dot(p[i].pos - m.pos, Vec2(cos(p[i].dir), sin(p[i].dir)))
    end
    min, max = extrema(db)
    (db - min) ./ (max - min)
end


"order_parameters computes the polarization and rotation of a swarm."
function order_parameters(p::Vector{State})
    m = mean(p)
    up, ur = Vec2(0, 0), 0.0
    @inbounds for i in eachindex(p)
        u = unit(p[i].vel)
        up += u
        ur += cross(u, unit(p[i].pos - m.pos))
    end
    (norm(up) / length(p), abs(ur) / length(p))
end

"bindist returns the ID and center of the nearest bin around each value in v."
function bindist(v::Vector{Float64}, bounds::Tuple{Real, Real}, nbins::Integer)
    edge = linspace(bounds..., nbins + 1)
    center = (edge[1:end-1] + edge[2:end]) / 2
    min, max = center[1], center[end]
    id = zeros(Int, length(v))
    val = zeros(length(v))
    @inbounds for i in eachindex(v)
        if isnan(v[i])
            id[i] = 0
            val[i] = NaN
        else
            id[i] = clamp(1 + round(Int, (nbins - 1) * (v[i] - min) / (max - min)), 1, nbins)
            val[i] = center[id[i]]
        end
    end
    return id, val
end


# Plotting
# --------

function stdplot(df::AbstractDataFrame)
    # compute mean and SEM
    dfb = by(df[df[:SwarmState].==:Polarized,:], [:Kind, :BinFromBack]) do d
        m, s = mean(d[:Info]), sem(d[:Info])
        DataFrame(Dist=d[1,:BinDistFromBack], Mean=m, Min=m-s, Max=m+s)
    end

    # standardize units
    dfb = by(dfb, :Kind) do d
        m, s = mean(d[:Mean]), std(d[:Mean])
        DataFrame(Dist=d[:Dist], Mean=(d[:Mean]-m)./s, Min=(d[:Min]-m)./s, Max=(d[:Max]-m)./s)
    end

    # plot
    p1 = plot(unique(dfb), x=:Dist, y=:Mean, ymin=:Min, ymax=:Max, color=:Kind, Geom.point, Geom.errorbar,
        Guide.xlabel("Normalized distance from back to front (polarized groups only)"),
        Guide.ylabel("Standardized units"))

    # compute mean and SEM
    dfe = by(df[df[:SwarmState].==:Polarized,:], [:Kind, :BinFromEdge]) do d
        m, s = mean(d[:Info]), sem(d[:Info])
        d[1,:BinFromEdge] > 0 || return DataFrame()
        DataFrame(Dist=d[1,:BinDistFromEdge], Mean=m, Min=m-s, Max=m+s)
    end


    # standardize units
    dfe = by(dfe, :Kind) do d
        m, s = mean(d[:Mean]), std(d[:Mean])
        DataFrame(Dist=d[:Dist], Mean=(d[:Mean]-m)./s, Min=(d[:Min]-m)./s, Max=(d[:Max]-m)./s)
    end

    # plot
    p2 = plot(dfe, x=:Dist, y=:Mean, ymin=:Min, ymax=:Max, color=:Kind, Geom.point, Geom.errorbar,
        # Guide.xlabel("Normalized distance from edge to center"),
        Coord.cartesian(xmin=0, xmax=maximum(dfe[:Dist])+minimum(dfe[:Dist])),
        Guide.xlabel("Distance from edge (body length)"),
        Guide.ylabel("Standardized units"))

    p = vstack(p1, p2)

    # draw(PDF("info.pdf", 6inch, 8inch), p)

    return p
end


function bounds(p::Vector{State})
    xmin, xmax = extrema([v.pos.x for v in p])
    ymin, ymax = extrema([v.pos.y for v in p])
    (xmin - 1, xmax + 1, ymin - 1, ymax + 1)
end

"netplot plots a weighted directed network of oriented ellipses."
netplot(p::Vector{State}, w::Matrix{Float64}) = netplot(p, w, bounds(p))

function netplot(p::Vector{State}, w::Matrix{Float64}, bounds)
    xmin, xmax, ymin, ymax = bounds
    box = UnitBox(xmin, ymax, xmax - xmin, ymin - ymax)
    c1 = context()
    for i in eachindex(p), j in eachindex(p)
        w[i,j] > 0.01 || continue
        c1 = compose(c1, (context(), line([(p[i].pos.x, p[i].pos.y), (p[j].pos.x, p[j].pos.y)]), stroke(RGBA(i<j, 0, i>j, w[i,j]))))
    end
    c2 = context()
    for i in eachindex(p)
        ctx = context(rotation=Rotation(-angle(p[i].vel), (p[i].pos.x, p[i].pos.y)))
        c2 = compose(c2, (ctx, ellipse(p[i].pos.x - 0.8/2, p[i].pos.y, 1/2, 0.125/2)))
        # c2 = compose(c2, myellipse(p[i].pos, Vec2(1, 0.125), 0.8, angle(p[i].vel)))
    end
    compose(context(units=box), c2, c1)
end

function myellipse(pos::Vec2, size::Vec2, offset::Real, θ::Real)
    N = 51
    R = [cos(θ) -sin(θ); sin(θ) cos(θ)]
    points = Vector{NTuple{2,Float64}}(N)
    for i in 1:N
        ϕ = 2(i-1)π / (N+1)
        x = R * [(cos(ϕ)-offset)*size.x/2, sin(ϕ)*size.y/2]
        points[i] = (pos.x + x[1], pos.y + x[2])
    end
    polygon(points)
end

colorplot(p::Vector{State}, by::Vector{Float64}) = colorplot(p, by, bounds(p))
function colorplot(p::Vector{State}, by::Vector{Float64}, bounds)
    xmin, xmax, ymin, ymax = bounds
    box = UnitBox(xmin, ymax, xmax - xmin, ymin - ymax)
    c = context()
    for i in eachindex(p)
        c = compose(c, (context(), myellipse(p[i].pos, Vec2(1, 0.125), 0.8, p[i].dir), fill(RGB(1, 1-by[i], 0))))
    end
    compose(context(units=box), c)
end


"netvid make a video of the dynamic network of interaction."
function netvid(p::Matrix{State}, mask::BitArray{2}, si::Array{Float64, 3})
    xmin, xmax, ymin, ymax = bounds(p[mask])
    r = (ymax - ymin) / (xmax - xmin)
    dir = "plots/vid/net"
    try rm(dir, recursive=true) end
    try mkdir(dir) end
    K = size(p, 2)
    for k in 1:K
        @printf("\r%3d%%", 100(k-1) / K)
        m = mask[:,k]
        n = netplot(p[m,k], si[m,m,k], (xmin, xmax, ymin, ymax))
        n = compose(context(), n, (context(), rectangle(), fill(colorant"white")))
        file = @sprintf("%08d.png", k)
        # draw(PNG(joinpath(dir, file), 8inch, r*8inch), n)
        draw(PNG(joinpath(dir, file), 1440px, 800px), n)
    end
    println("\r100%")
end



function colorvidperso(p::Matrix{State}, mask::BitArray{2}, pi::Array{Float64, 2})
    xmin, xmax, ymin, ymax = bounds(p[mask])
    r = (ymax - ymin) / (xmax - xmin)
    dir = "plots/vid/pi"
    try rm(dir, recursive=true) end
    try mkdir(dir) end
    K = size(p, 2)
    for k in 1:K
        @printf("\r%3d%%", 100(k-1) / K)
        m = mask[:,k]
        n = colorplot(p[m,k], pi[m,k], (xmin, xmax, ymin, ymax))
        n = compose(context(), n, (context(), rectangle(), fill(colorant"black")))
        file = @sprintf("%08d.png", k)
        # draw(PNG(joinpath(dir, file), 8inch, r*8inch), n)
        draw(PNG(joinpath(dir, file), 1440px, 800px), n)
    end
    println("\r100%")
end

function colorvidsocial(p::Matrix{State}, mask::BitArray{2}, si::Array{Float64, 3})
    xmin, xmax, ymin, ymax = bounds(p[mask])
    r = (ymax - ymin) / (xmax - xmin)
    dir = "plots/vid/si"
    try rm(dir, recursive=true) end
    try mkdir(dir) end
    K = size(p, 2)
    for k in 1:K
        @printf("\r%3d%%", 100(k-1) / K)
        m = mask[:,k]
        n = colorplot(p[m,k], 50000 .* cc(si[m,m,k]), (xmin, xmax, ymin, ymax))
        n = compose(context(), n, (context(), rectangle(), fill(colorant"black")))
        file = @sprintf("%08d.png", k)
        # draw(PNG(joinpath(dir, file), 8inch, r*8inch), n)
        draw(PNG(joinpath(dir, file), 1440px, 800px), n)
    end
    println("\r100%")
end


function plotmap(df::AbstractDataFrame)
    df2 = by(df[df[:SwarmState].==:Polarized,:], [:Kind, :BinFromBack, :BinFromEdge]) do d
        # if nrow(d) < 100 return DataFrame() end
        if d[1,:BinFromEdge] == 0 return DataFrame() end
        DataFrame(BinDistFromBack=d[1,:BinDistFromBack], BinDistFromEdge=d[1,:BinDistFromEdge], Info=median(d[:Info]), Count=nrow(d))
    end
    p = plot(df2[df2[:Kind].==:Personal,:], x=:BinDistFromBack, y=:BinDistFromEdge, color=:Info, Geom.rectbin,
        Guide.xlabel("Normalized distance from back to front"),
        Guide.ylabel("Distance from edge (body length)"),
        Guide.title("Polarized groups only"),
        Guide.colorkey("External\nvisual field"))
    draw(PDF("heatmap_personal.pdf", 5.5inch, 4inch), p)
    p = plot(df2[df2[:Kind].==:Social,:], x=:BinDistFromBack, y=:BinDistFromEdge, color=:Info, Geom.rectbin,
        Guide.xlabel("Normalized distance from back to front"),
        Guide.ylabel("Distance from edge (body length)"),
        Guide.title("Polarized groups only"),
        Guide.colorkey("Social influence"))
    draw(PDF("heatmap_social.pdf", 5.5inch, 4inch), p)

    df3 = by(df[df[:SwarmState].==:Polarized,:], [:Kind, :BinFromBack, :BinFromEdgeRel]) do d
        # if nrow(d) < 100 return DataFrame() end
        if d[1,:BinFromEdge] == 0 return DataFrame() end
        DataFrame(BinDistFromBack=d[1,:BinDistFromBack], BinDistFromEdge=d[1,:BinDistFromEdgeRel], Info=median(d[:Info]), Count=nrow(d))
    end
    p = plot(df3[df3[:Kind].==:Personal,:], x=:BinDistFromBack, y=:BinDistFromEdge, color=:Info, Geom.rectbin,
        Guide.xlabel("Normalized distance from back to front"),
        Guide.ylabel("Distance from edge (body length)"),
        Guide.title("Polarized groups only"),
        Guide.colorkey("External\nvisual field"))
    draw(PDF("heatmap_personal_rel.pdf", 5.5inch, 4inch), p)
    p = plot(df3[df3[:Kind].==:Social,:], x=:BinDistFromBack, y=:BinDistFromEdge, color=:Info, Geom.rectbin,
        Guide.xlabel("Normalized distance from back to front"),
        Guide.ylabel("Distance from edge (body length)"),
        Guide.title("Polarized groups only"),
        Guide.colorkey("Social influence"))
    draw(PDF("heatmap_social_rel.pdf", 5.5inch, 4inch), p)

    p = plot(df2[df2[:Kind].==:Personal,:], x=:BinDistFromBack, y=:BinDistFromEdge, color=:Count, Geom.rectbin,
        Guide.xlabel("Normalized distance from back to front"),
        Guide.ylabel("Distance from edge (body length)"),
        Guide.title("Polarized groups only"),
        Guide.colorkey("Count"))
    draw(PDF("heatmap_personal_count.pdf", 5.5inch, 4inch), p)
    p = plot(df3[df3[:Kind].==:Personal,:], x=:BinDistFromBack, y=:BinDistFromEdge, color=:Count, Geom.rectbin,
        Guide.xlabel("Normalized distance from back to front"),
        Guide.ylabel("Distance from edge (body length)"),
        Guide.title("Polarized groups only"),
        Guide.colorkey("Count"))
    draw(PDF("heatmap_social_count.pdf", 5.5inch, 4inch), p)
end

